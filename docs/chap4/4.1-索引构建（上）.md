# 索引构建（上）

## 硬件的视角

这一章的内容很多会涉及到计算机组成原理和计算机系统结构里面的内容，略有一点点硬核，请同学们做好心理准备，若实在看不下去就跳过吧哈哈哈哈。

![1735581513217](C:\Users\马世拓\AppData\Roaming\Typora\typora-user-images\1735581513217.png)

访问内存数据比访问磁盘数据快很多，只需要几个时钟周期（大概5×10-9s）便可以访问内存中的一字节（快10倍），而从磁盘传输一字节所需要的时间则长得多（2×10-8s）。那么，尽可能的把数据存在内存中，特别是那些访问频繁的数据。将频繁访问的磁盘数据放入内存的技术称为高速缓存caching。

（多级存储的示意图）

进行磁盘读写时，磁头移到数据所在的磁道需要一段时间，该时间称为寻道时间，对典型的磁盘来说平均在5ms左右。寻道期间并不进行数据的传输。为了使数据传输率最大，连续读取的数据块也应该在磁盘上连续存放。
基于2007年的系统参数，大概只需要0.2s就可以将一个连续存放的10MB数据块从磁盘传输到内存，但是该数据如果存在100个非连续的块中，需要移动100次磁头，因此总时间可能需要0.2+100×(5×10-3)=0.7s

操作系统往往以数据块为单位进行读写。因此，从磁盘读取一个字节和读取一个数据块所耗费的时间可能一样多。数据块的大小通常为8KB、16KB、32KB、64KB到256KB。内存中保存读写块的区域称为缓冲器（buffer）。数据从磁盘传输到内存是由系统总线而不是处理器来实现的，意味着在磁盘IO时处理器仍然可以处理数据。可以利用这一点来加速传输过程，比如将数据压缩再存储在磁盘上。采用高效的解压缩算法，读磁盘压缩数据再解压所花的时间往往比直接读取未压缩数据的时间要少。

IR系统的服务器的典型配置是GB（10~100GB）级别的内存，TB级的硬盘。容错处理的代价非常昂贵：采用多台普通机器会比一台提供容错的机器的价格更便宜。

## 基于块的排序索引

字典可以被看做是一种元数据，本身不会很大，但是！倒排索引表，规模巨大！只能存储在磁盘上，那么就会产生访问延迟。

关于倒排索引的构建，我们在第二章当中已经讲述过。对于小文档来说，这个过程可以在内存中完成。本讲我们主要讨论在大规模文档集条件下需要引入二级存储介质时的索引方法。

在构建索引时，每次分析一篇文档。对于每个词项而言，其倒排记录表不到最后一篇文档都是不完整的。那么能否在最后排序之前将前面产生的倒排记录表全部放在内存中？答案显然是否定的，特别是对大规模的文档集来说，如果每条倒排记录占10–12个字节，那么对于大规模语料，需要更大的存储空间。以RCV1为例，T = 100,000,000，这些倒排记录表倒是可以放在2010年的一台典型配置的计算机的内存中。但是这种基于内存的索引构建方法显然无法扩展到大规模文档集上。因此，需要在磁盘上存储中间结果。

这就涉及到数据结构里面大家可能忘记掉的一个知识——外部排序。

为了达到可以接受的速度，对该算法的核心要求是：在排序时尽量减少磁盘随机寻道的次数。因为磁盘顺序读取速度会比随机寻道速度快很多，需要对T = 100,000,000条无位置信息的倒排记录进行排序。每条倒排记录需要12字节 (4+4+4: termID, docID, df)
可以定义一个能够包含10,000,000条上述倒排记录的数据块，这个数据块很容易放入内存中(12*10M=120M)。这也就引出了我们今天的主题——基于块的索引排序算法。

BSBI（基于块的索引算法）排序思路：

- 将文档集分割成几个大小相等的部分
- 将每个部分的词项ID-文档ID对排序
- 将中间产生的临时排序结果放在磁盘中
- 将所有的中间文件合并成最终的索引

![1735582372383](C:\Users\马世拓\AppData\Roaming\Typora\typora-user-images\1735582372383.png)

该算法将文档解析成词项ID-文档ID对，并在内存中一直处理，直到累积至放满一个固定大小的块空间为止（ParseNextBlock）。选择合适的块大小，使之能方便加载到内存并允许在内存中快速排序。排序后的块转换成倒排索引格式后写入磁盘。

算法的最后一步是将10个块索引同时合并成一个索引文件。同时打开所有块对应的文件，内存中维护了为10个块准备的读缓冲区和一个为最终合并索引准备的写缓冲区。每次迭代中，利用优先队列或者类似的数据结构选择最小的未处理词项ID进行处理。读入词项的倒排记录表并合并，结果写回磁盘中。

> 算法最主要的时间消耗在排序上，因此时间复杂度是O(TlogT)，T是词项-文档ID对的个数。
>
> 实际上，ParseNextBlock占用了大部分时间，然后是MergingBlocks，同样是因为磁盘寻道延迟 vs. 内存访问延迟。

![1735582475216](C:\Users\马世拓\AppData\Roaming\Typora\typora-user-images\1735582475216.png)

