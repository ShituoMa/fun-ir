# 词典与通配符检索

## 词典搜索的数据结构

给定倒排索引及查询，我们的首要任务是确定每个查询词项是否在词汇表中，如果在，则返回该词项对应的倒排记录表的指针。词汇表的查询操作往往采用一种称为词典的经典数据结构。

针对每个词项，我们要存储词的内容、词的词频、词的文档频率、词的倒排记录表等等。暂定每条词项的上述信息均采用定长的方式存储，假定所有词项的信息采用数组存储。

在Python当中有一个数据结构就叫做字典（Dict），在Java里面也有类似的数据结构（HashMap），那这些数据结构是怎么快速做检索的？主要有两大检索方案：哈希表与树。这也是数据结构里面讲过的哈。

### 哈希表

哈希函数是一种将任意长度的输入数据通过散列算法转换成固定长度输出的函数。这个输出通常被称为哈希值或散列值。哈希函数具有以下一些重要特性：

1. **确定性**：对于同一个输入，哈希函数总是产生相同的输出。
2. **快速计算**：哈希值可以快速计算出来。
3. **抗碰撞性**：不同的输入很难产生相同的哈希值（即难以找到两个不同的输入，使得它们的哈希值相同）。
4. **雪崩效应**：输入数据的微小变化会导致输出哈希值的显著变化。

### 哈希函数与信息检索的关系

在信息检索中，哈希函数被广泛应用于以下几个方面：

#### 1. 建立索引
- **倒排索引**：在构建倒排索引时，可以使用哈希函数将文档ID或词项映射到一个固定大小的数组中，从而快速定位到包含特定词项的文档列表。例如，对于词项 \( t \)，可以计算其哈希值 \( h(t) \)，然后将 \( t \) 的相关信息存储在哈希表的 \( h(t) \) 位置。
- **快速查找**：哈希表可以实现常数时间复杂度 \( O(1) \) 的查找操作，这对于快速检索文档中的词项非常有用。

#### 2. 处理相似性查询
- **局部敏感哈希（LSH）**：在处理相似性查询时，如查找相似文档或相似词项，局部敏感哈希可以将相似的输入映射到相同的或相近的哈希值。例如，对于两个相似的文档 \( d_1 \) 和 \( d_2 \)，通过设计合适的哈希函数，可以使得 \( h(d_1) \) 和 \( h(d_2) \) 相近，从而快速找到相似文档。

#### 3. 数据去重
- **文档去重**：在处理大量文档时，可以使用哈希函数对文档内容进行哈希处理，然后将哈希值存储在一个集合中。当遇到新的文档时，计算其哈希值并检查是否已存在于集合中，从而实现快速去重。

### 公式示例
一个简单的哈希函数可以表示为：
\[ h(x) = x \mod m \]
其中，\( x \) 是输入数据，\( m \) 是哈希表的大小。这个函数将输入数据映射到一个介于 0 到 \( m-1 \) 之间的整数范围内.

在信息检索中，哈希函数的使用可以显著提高数据处理的效率和准确性，是许多检索系统不可或缺的一部分。

- 哈希函数 任意函数h(x)都可以说哈希函数，一般来说，一个良好的哈希函数可以尽量避免重复。x的集合是参数域，h(x)的集合是值域。

- 完美哈希函数  完美哈希函数，就是完全不会冲突的哈希函数，这要求函数的值域至少比参数域要大

- 最小完美哈希函数 最小完美哈希函数，就是指函数的值域和参数域的大小完全相等，一个也不多

- 保序最小完美哈希函数 保序的意思就是指这个哈希之后顺序是不变的，同时还能满足其他两个条件。

  > 保序最小完美哈希函数的优点就是形式上很完美，就像给一个排好序的文档编上的序号一般紧凑可靠。但是这个函数有两个缺点，一是必须事前知道原数据集，二是需要花一定的CPU来生成这个函数。对于数据仓库类的线下搜索应用，这个算法是有用武之地的。但对于强调实时的数据业务，这个算法是不适合的。
  >
  > 保序最小完美哈希函数是一个静态Hash函数，可以非常有效的缩减索引所需要的空间。《Managing Gigabytes》一书中有一个对比，如果直接使用字符串数组，100万个术语需要28MB的空间，而是用这样的哈希函数，可以缩减到12MB。索引小一点，磁盘就能读得快一点，查询就能快一点。所以这个哈希函数对于提高性能是非常给力的。但是它是静态的，就意味着事前必须知道需要哈希哪些数据。同时生成的算法比较复杂，需要很长的时间来建立索引。没有办法实时添加更新，限制了它的应用范围。输入法的词库，数据仓库的查询索引，还有一些不需要更新且对性能有要求的场景，这个算法是适用的。

局部敏感哈希的基本思想类似于一种空间域转换思想。LSH算法基于一个假设，如果两个文本在原有的数据空间是相似的，那么分别经过哈希函数转换以后的它们也具有很高的相似度；相反，如果它们本身是不相似的，那么经过转换后它们应仍不具有相似性。它的主要作用就是从海量的数据中挖掘出相似的数据，可以具体应用到文本相似度检测、网页搜索等领域。

当然了，现在也有用机器学习做哈希函数的（Learning to Hash）。

![1735579495383](C:\Users\马世拓\AppData\Roaming\Typora\typora-user-images\1735579495383.png)

而面对这些问题，就需要用到我们的搜索树啦：

### 搜索树

搜索树方式能够解决上面提到的大部分问题，可以支持以automat开始的前缀式查询。最出名的搜索树是二叉树（binary tree），其每个内部节点都有两个子节点。在二叉树中搜索词项要从根节点开始，而每个内部节点都代表一个二值测试，测试的结果用于确定下一步应该搜索的子树。

![1735579562596](C:\Users\马世拓\AppData\Roaming\Typora\typora-user-images\1735579562596.png) 

- 优点：
  - 树可以支持前缀查找(相当于对词典再建一层索引)
- 缺点：
  - 二叉树的搜索速度略低于哈希表方式： O(logM), 其中 M 是词汇表大小，即所有词项的数目
  - 当然，O(logM) 仅仅对平衡树成立，但是使二叉树重新保持平衡开销很大

有一种减少重新平衡化处理开销的方法，即允许内部节点的子树数目在某个固定区间内变化，比如词典搜索中普遍使用的B树。B树上的每个内部节点代表一个用于确定字符序列范围的测试条件。B树可以看成将二叉树的多层“折叠”成一层而得到的树结构，在内存空间不足以存下全部词典而必须要将部分词典常驻磁盘时，这样做非常高效，因为在将词典调入内存时支持后续二值测试的预读取。B树中整数a和b取决于磁盘块的大小，B树的搜索速度为O(logM) ，但是没有平衡问题。

## 通配符查询

通配符查询怎么用呢？比如说，用户英语不好，打字打忘了怎么拼了只记得个大概，怎么纠正过去？用户想查询的单词是它的变形，怎么纠正？用户不熟悉外来语的拼写形式，怎么纠正？这些都可以用通配符查询。

例如：mon\*: 找出所有包含以 mon开头的词项的文档
因为通配符\*在查询字符串末尾仅出现一次，称为尾通配符查询。基于搜索树的词典结构对于处理尾通配符查询来说非常方便，可以依次按照字符m、o、n从上到下遍历搜索树，直到列举词典中以mon开头的词集合W为止，最后在普通倒排索引中进行|W|次查找后取出W中所有词项对应的文档。

那如果通配符不出现在末尾怎么办？将所有的词项倒转过来，然后基于它们建一棵反向B树，对反向B树遍历后可以返回所有包含同一后缀的词项。同时使用B树和反向B树，可以处理更一般的查询（例如se*mon）。通过B树返回前缀se的词项子集W，再通过反向B树返回所有后缀为mon的词项子集R，求交集W∩R。

另外一种方法，轮排(permuterm) 索引，它是倒排索引的一种特殊形式。轮排索引称为轮排树更恰当，但是轮排索引的称呼已经使用非常普遍。

<img src="C:\Users\马世拓\AppData\Roaming\Typora\typora-user-images\1735579963526.png" alt="1735579963526" style="zoom:50%;" />

- 首先，在字符集中引入一个新的符号\$，用于标识词项结束
- 词项hello表示成扩展的词项hello\$
- 然后，构建一个轮排索引，对扩展词项的每个旋转结果都构造一个指针来指向原始词项

如何查找存在多个通配符fi*mo*er?

- 首先返回轮排索引中er$fi*对应的词项集合
- 然后通过穷举法检查该集合中的每个元素，过滤掉其中不包含mo的词项
- 再利用剩下的词项去查普通倒排索引，从而得到最后的结果

![1735580009647](C:\Users\马世拓\AppData\Roaming\Typora\typora-user-images\1735580009647.png)

尽管轮排索引结构简单，但是会引起空间的急剧增长。对于一部英语词典来说，这种增长可能达到10倍左右。使用K-gram索引，比轮排索引空间开销要小。

> 枚举一个词项中所有连读的k个字符构成k-gram 。这个部分其实我们在自然语言处理教程第一章讲语言模型的时候就介绍过，那个地方叫N-Gram，是一个意思。

在k-gram索引结构中，其词典由词汇表中所有词项的所有k-gram形式构成，而每个倒排记录表则包含该k-gram的词项组成。

（案例练习）

